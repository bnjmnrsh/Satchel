{"version":3,"file":"Satchel.min.js","sources":["../src/Satchel.js"],"sourcesContent":["/**\n * A utility library for managaing namespaced sessionStorage and localStorage entries.\n */\nclass Satchel {\n  #pocketKey\n  #store\n  #settings\n\n  /**\n   * @class Satchel\n   * @classdec Create new Satchel instance\n   * @param {string|null} key Storage key\n   * @param {object} cargo The cargo payload to be saved to Storage\n   * @property {object|string} cargo.data The data to be saved, may be string or object\n   * @property {number|null} cargo.expiry The expiry time of the cargo ,may be a number or null\n   * @param {boolean} [local=false] Specify sessionStorage (default) or localStorage\n   * @param {string} [pocket='pocket'] Namespace for Storage keys, default is 'pocket'\n   */\n  constructor(key = null, cargo = {}, local = false, pocket = 'pocket') {\n    this.#store = local ? window.localStorage : window.sessionStorage\n    if (!key) throw new Error('Satchel: a \"key\" is required.')\n    if (typeof key !== 'string')\n      throw new Error('Satchel: \"key\" must be a string.')\n    if (typeof cargo !== 'object')\n      throw new Error('Satchel: {cargo} must be an object.')\n    if (typeof local !== 'boolean')\n      throw new Error('Satchel: local must be a boolean.')\n    if (typeof pocket !== 'string')\n      throw new Error('Satchel: \"pocket\" must be an string.')\n\n    this.stcl = Satchel.stcl\n    this.#pocketKey = `${this.stcl}.${pocket}.${key}`\n    this.#settings = { data: undefined, expiry: null }\n\n    cargo = { ...this.#settings, ...cargo }\n\n    // Set the cargo to Storage\n    this.set(cargo)\n  }\n\n  /**\n   * Returns an object of age and freshness related data\n   *\n   * @typedef {object} age object\n   * @property {number} age in milliseconds\n   * @property {number} creation Date.now() (ms)src/Satchel.js\n   * @property {boolean} fresh if Store key is fresh\n   * @return {Age} An age object representing the age of the current Store key.\n   */\n  age() {\n    const store = JSON.parse(this.#store.getItem(this.#pocketKey))\n    if (!store) return null\n    return {\n      age: Number(Date.now() - store.creation),\n      creation: Number(store.creation),\n      expiry: store.expiry ? Number(store.expiry) : null,\n      fresh: Boolean(this.isFresh())\n    }\n  }\n\n  /**\n   * Remove the current namespaced key from the store.\n   *\n   * @returns { boolian:true | null } Returns true on success, or null if no record found.\n   */\n  bin() {\n    const item = this.#store.getItem(this.#pocketKey)\n    if (!item) return null\n    this.#store.removeItem(this.#pocketKey)\n    Satchel.#emit({\n      key: String(this.#pocketKey),\n      oldValue: String(item),\n      storageArea: String(Satchel.#storageAreaString(this.#store)),\n      action: 'bin'\n    })\n    return true\n  }\n\n  /**\n   * Get the data for the current Storage key.\n   *\n   * @param {boolean} ignoreStale flag to ignore stale entries from a \"pocket\"\n   * @returns {object|boolan:false} the data for the stored key or false.\n   */\n  get(ignoreStale = false) {\n    const item = this.#store.getItem(this.#pocketKey)\n    if (!item) return false\n    if ((this.isFresh() && !ignoreStale) || ignoreStale) {\n      return JSON.parse(item)\n    }\n    return false\n  }\n\n  /**\n   * Sets the data, for a given key and namespace\n   *\n   * @param {object} settings object\n   * @property {object|string} data the Storage object to set\n   * @property {number|null} expiry the expiery date in (ms)\n   * @property {number} creation the creation date in (ms) Date.now()\n   *\n   * @return {object} Satchel\n   */\n  set({ data, expiry }) {\n    if (typeof expiry !== 'number' && expiry !== null) {\n      throw new Error('Satchel: Expiry must be null or a number.')\n    }\n    if (data && typeof data !== 'string' && typeof data !== 'object') {\n      throw new Error('Satchel: Data must be a string or an object.')\n    }\n    const storedEntry = this.get(true)\n    const temp = {}\n    temp.data = data || null\n    temp.expiry = expiry || null\n\n    if (!data && !expiry && storedEntry)\n      throw new Error(\n        `Satchel: The key (\"${\n          this.#pocketKey\n        }\") already exists in ${Satchel.#storageAreaString(\n          this.#store\n        )}, and \"data\" and \"expiry\" atributes have not been set, set these or create a new unique key.`\n      )\n\n    // dont overwrite existing creation time\n    temp.creation = Number(storedEntry.creation) || Date.now()\n    // Set storage values\n    this.#store.setItem(this.#pocketKey, JSON.stringify(temp))\n\n    Satchel.#emit({\n      key: String(this.#pocketKey),\n      newValue: JSON.stringify(temp),\n      oldValue: storedEntry ? JSON.stringify(storedEntry) : null,\n      storageArea: String(Satchel.#storageAreaString(this.#store)),\n      action: 'set'\n    })\n    return this\n  }\n\n  /**\n   * Check if current item is fresh.\n   *\n   * @returns {boolean|null} true if the item has not expired, null if the record doesn't exist.\n   */\n  isFresh() {\n    const store = JSON.parse(this.#store.getItem(this.#pocketKey))\n    if (!store) return null\n    return Boolean(!store?.expiry ? true : store.expiry - Date.now() > 0)\n  }\n\n  /**\n   * Returns the current namespaced Store key (pocket.key), the key is prefixed with 'stcl'.\n   * Note that this is the internal reference to the key, not proof the key has been set to Storage.\n   *\n   * @returns {string} the key to the current pocket-key\n   */\n  getKey() {\n    return String(this.#pocketKey)\n  }\n\n  /**\n   * Returns array of keys for a 'Pocket' namespace.\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns {array} array of Storage keys for the current pocket.\n   */\n  static getAllPocketKeys(pocket = 'pocket', local = false) {\n    const store = local ? window.localStorage : window.sessionStorage\n\n    const allKeys = Object.keys(store)\n      .map((key) => {\n        return key.startsWith(this.stcl + '.' + pocket) ? key : ''\n      })\n      .filter((e) => {\n        return e\n      })\n\n    return Array.from(allKeys)\n  }\n\n  /**\n   * Get the Storage type as a string 'localStorage' or 'sessionStorage'\n   *\n   * @param {object} Storage object\n   * @returns {string} the Storage type as a string 'localStorage' or 'SessionStorage'\n   */\n  static #storageAreaString(store) {\n    return store === window.localStorage ? 'LocalStorage' : 'SessionStorage'\n  }\n\n  /**\n   * Emulates the StorageEvent API, which may be preferable for some use cases.\n   * https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent\n   *\n   * Emit custom events for Satchel\n   * @typedef {CustomEvent}\n   * @param {object} detail Event details\n   * @property {string|null} detail.key name of the Storage key being called\n   * @property {string|null} detail.pocket name of the Storage pocket being cleaned\n   * @property {string|null} detail.newValue the updated value of the Storage key\n   * @property {string|null} detail.oldValue the old value of the Storage key\n   * @property {number|null} detail.keysBefore then number of keys in the pocket before emptyPocket or tidyPocket\n   * @property {number|null} detail.keysAfter then number of keys in the pocket after emptyPocket or tidyPocket\n   * @property {string} detail.storageArea, the type of Storage object\n   * @property {string} detail.url, the url of the document whoes key changed\n   * @property {string} detail.action the name of the Satchel function emiting the event\n   * @property {boolean} [pocketClean = false] Optional flag to indiacte a emptyPocket or tidyPocket opperation.\n   * @returns {CustomEvent} CustomEvent\n   */\n  static #emit(detail = {}, pocketClean = false) {\n    let required = {\n      key: null,\n      newValue: null,\n      oldValue: null,\n      storageArea: null,\n      url: String(window.location.href),\n      action: null\n    }\n    if (pocketClean) {\n      required = {\n        pocket: null,\n        keysBefore: null,\n        keysRemaining: null,\n        storageArea: null,\n        url: String(window.location.href),\n        action: null\n      }\n    }\n    detail = { ...required, ...detail }\n    const event = new CustomEvent('Satchel', {\n      bubbles: true,\n      cancelable: true,\n      detail\n    })\n    return document.dispatchEvent(event)\n  }\n\n  /**\n   * Clears all items regardless of freshness from a given 'pocket' namespace\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns {array} The number of items remaing in store, which if sucessful should be 0.\n   */\n  static emptyPocket(pocket = 'pocket', local = false) {\n    const store = local ? window.localStorage : window.sessionStorage\n    const keysBefore = Satchel.getAllPocketKeys(pocket, local)\n\n    Object.keys(keysBefore).forEach((key) => {\n      store.removeItem(keysBefore[key])\n    })\n    const keysRemaining = Satchel.getAllPocketKeys(pocket, local).length\n\n    Satchel.#emit(\n      {\n        pocket: pocket,\n        keysBefore: keysBefore.length,\n        keysRemaining,\n        storageArea: Satchel.#storageAreaString(store),\n        action: 'emptyPocket'\n      },\n      true\n    )\n\n    return keysRemaining\n  }\n\n  /**\n   *  Removes all expired items from a given 'pocket' namespace\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns The number of items remaing in store that have yet to expire.\n   */\n  static tidyPocket(pocket = 'pocket', local = false) {\n    const store = local ? window.localStorage : window.sessionStorage\n    const keysBefore = Satchel.getAllPocketKeys(pocket, local)\n    if (!keysBefore.length) return null\n\n    Object.keys(keysBefore).forEach((key) => {\n      const expiry = JSON.parse(store.getItem(keysBefore[key])).expiry\n      if (!expiry || expiry - Date.now() > 0) return null\n      store.removeItem(keysBefore[key])\n    })\n    const keysRemaining = Satchel.getAllPocketKeys(pocket, local).length\n\n    Satchel.#emit(\n      {\n        pocket: String(pocket),\n        keysBefore: Number(keysBefore.length),\n        keysRemaining: Number(keysRemaining),\n        storageArea: String(Satchel.#storageAreaString(store)),\n        action: 'tidyPocket'\n      },\n      true\n    )\n    return keysRemaining\n  }\n\n  /**\n   * Returns an instance of Satchel associated with the given key, pocket,store, or false if none is found.\n   *\n   * @param {string} key key for the stored item\n   * @param {string} [pocket='pocket'] namespace prefix, default 'pocket'\n   * @param {string} [local='false'] specify sessionStorage (default) or localStorage\n   * @returns {Satchel|false} new Satchel instance | false\n   */\n  static getSatchel(key, pocket = 'pocket', local = false) {\n    if (!key) throw new Error('Satchel: a \"key\" is required.')\n    if (typeof key !== 'string')\n      throw new Error('Satchel: \"key\" must be a string.')\n    if (typeof pocket !== 'string')\n      throw new Error('Satchel: \"pocket\" must be an string.')\n    if (typeof local !== 'boolean')\n      throw new Error('Satchel: local must be a boolean.')\n\n    const pocketKey = `${Satchel.stcl}.${pocket}.${key}`\n    const store = local ? window.localStorage : window.sessionStorage\n    let item = JSON.parse(store.getItem(pocketKey))\n    if (!item || item.length === 0) return false\n\n    return new Satchel(key, item, local, pocket)\n  }\n}\n\nSatchel.stcl = 'stcl'\nexport { Satchel }\n"],"names":["Satchel","pocketKey","store","settings","constructor","key","cargo","local","pocket","this","window","localStorage","sessionStorage","Error","stcl","data","undefined","expiry","set","age","JSON","parse","getItem","Number","Date","now","creation","fresh","Boolean","isFresh","bin","item","removeItem","emit","String","oldValue","storageArea","storageAreaString","action","get","ignoreStale","storedEntry","temp","setItem","stringify","newValue","getKey","static","allKeys","Object","keys","map","startsWith","filter","e","Array","from","detail","pocketClean","required","url","location","href","keysBefore","keysRemaining","event","CustomEvent","bubbles","cancelable","document","dispatchEvent","getAllPocketKeys","forEach","length"],"mappings":"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"}