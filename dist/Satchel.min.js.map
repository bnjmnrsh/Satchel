{"version":3,"file":"Satchel.min.js","sources":["../src/Satchel.js"],"sourcesContent":["/**\n * A utility for managaing sessionStorage and localStorage\n *\n */\nclass Satchel {\n  #cargo\n  #pocketKey\n  #store\n  #settings\n\n  /**\n   * @class Satchel\n   * @classdec Create new Satchel instance\n   * @param {string} key Storage key\n   * @param {object} cargo The cargo payload to be saved to Storage\n   * @property {object|string} cargo.data The data to be saved, may be string or object\n   * @property {number|null} cargo.expiry The expiry time of the cargo ,may be a number or null\n   * @param {boolean} [local=false] Specify sessionStorage (default) or localStorage\n   * @param {string} [pocket='pocket'] Namespace for Storage keys, default is 'pocket'\n   */\n  constructor(key = null, cargo = {}, local = false, pocket = 'pocket') {\n    this.#store = local ? window.localStorage : window.sessionStorage\n    if (!key) throw new Error('Satchel: a key is required.')\n    this.stcl = Satchel.stcl\n    this.#pocketKey = `${this.stcl}.${pocket}.${key}`\n    this.#settings = { data: undefined, expiry: null }\n    this.#cargo = { ...this.#settings, ...cargo }\n\n    if (typeof this.#cargo.expiry !== 'number' && this.#cargo.expiry !== null) {\n      throw new Error('Satchel: Expiry must be null or a number.')\n    }\n    // Keep creation time from being edited\n    Object.defineProperty(this.#cargo, 'creation', {\n      enumerable: true,\n      writable: false,\n      value: Date.now()\n    })\n\n    // set the cargo in Storage\n    this.set(this.#cargo)\n  }\n\n  /**\n   * Returns an object of age and freshness related data\n   *\n   * @typedef {Object} Age object\n   * @property {number} age in milliseconds\n   * @property {number} creation Date.now() (ms)src/Satchel.js\n   * @property {boolean} fresh if Store key is fresh\n   * @return {Age} An age object representing the age of the current Store key.\n   */\n  age() {\n    const store = JSON.parse(this.#store.getItem(this.#pocketKey))\n    return {\n      age: Date.now() - store.creation,\n      creation: store.creation,\n      expiry: store.expiry,\n      fresh: this.isFresh()\n    }\n  }\n\n  /**\n   *\n   * @returns {null | boolian:false } nullif su\n   */\n  bin() {\n    this.#store.removeItem(this.#pocketKey)\n    if (!this.#store.getItem(this.#pocketKey)) {\n      Satchel.#emit({\n        type: this.#store,\n        key: this.#pocketKey,\n        action: 'bin'\n      })\n      return null\n    } else {\n      throw new Error('Satchel: Failure to bin key: ' + this.#pocketKey)\n    }\n  }\n\n  get(ignore = false) {\n    const item = this.#store.getItem(this.#pocketKey)\n    if (!item) return false\n    if ((this.isFresh() && !ignore) || ignore) {\n      return JSON.parse(item)\n    }\n    return false\n  }\n\n  /**\n   * Sets the data, for a given key and namespace\n   *\n   * @param {object} settings object\n   * @property {object|string} data the Storage object to set\n   * @property {number|null} expiry the expiery date in (ms)\n   * @property {number} creation the creation date in (ms) Date.now()\n   *\n   * @return {Object} Satchel\n   */\n  set({ data, expiry, creation }) {\n    if (typeof this.#cargo.expiry !== 'number' && this.#cargo.expiry !== null) {\n      throw new Error('Satchel: Expiry must be null or a number.')\n    }\n    if (typeof this.#cargo.creation !== 'number') {\n      throw new Error(\n        'Satchel: Creation must be null or a number, it should not be set directly.'\n      )\n    }\n    const storedEntry = this.get(true)\n    const temp = {}\n    temp.data = data || null // Key exsists but we are not setting a data attribute\n    temp.expiry = expiry || this.#cargo?.expiry || null\n\n    if (!data && !expiry && storedEntry)\n      throw new Error(\n        `Satchel: The key (\"${this.#pocketKey}\") already exists in ${\n          this.#store === window.localStorage\n            ? 'LocalStorage'\n            : 'SessionStorage'\n        }, and \"data\" and \"expiry\" atributes have not been set, set these or create a new unique key.`\n      )\n    // Key exsists and the creation property is being changed\n    if (!data && storedEntry && creation) {\n      throw new Error(\n        'Satchel: Overwriting a key\\'s \"creation\" property is not allowed.'\n      )\n    } else {\n      // dont overwrite existing creation time\n      temp.creation = storedEntry?.creation || this.#cargo.creation\n    }\n    // Set storage values\n    this.#store.setItem(this.#pocketKey, JSON.stringify(temp))\n\n    // Update internal reference object\n    this.#cargo = { ...this.#cargo, ...temp }\n\n    Satchel.#emit({\n      type: this.#store,\n      key: this.#pocketKey,\n      action: 'set',\n      data: temp,\n      oldData: storedEntry\n    })\n    return this\n  }\n\n  /**\n   * Check if current item is fresh.\n   *\n   * @returns {boolean} true if the item has not expired\n   */\n  isFresh() {\n    const store = JSON.parse(this.#store.getItem(this.#pocketKey))\n    return !store?.expiry ? true : store.expiry - Date.now() > 0\n  }\n\n  /**\n   * Returns the current namespaced Store key (pocket.key), the key is prefixed with 'stcl'\n   *\n   * @returns string\n   */\n  getKey() {\n    return this.#pocketKey\n  }\n\n  /**\n   * Returns array of keys for the a 'Pocket' namespace.\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns {array} array of Storage keys for the current pocket.\n   */\n  static getAllPocketKeys(pocket = 'pocket', local = false) {\n    const store = local ? window.localStorage : window.sessionStorage\n\n    return Object.keys(store)\n      .map((key) => {\n        return key.startsWith(this.stcl + '.' + pocket) ? key : ''\n      })\n      .filter(function (e) {\n        return e\n      })\n  }\n\n  /**\n   * Use Storage events?\n   * TODO:https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#responding_to_storage_changes_with_the_storageevent\n   *\n   * Emit custom events for Satchel\n   * @typedef {CustomEvent}\n   * @param {object} detail current CustomEvent details\n   * @property {string} detail.type, the type of Storage object\n   * @property {string} detail.key name of the Storage key being called\n   * @property {string} detail.action the name of the function emiting the event\n   * @property {string | null} detail.data the stringified data for the given key\n   * @returns {CustomEvent} CustomEvent\n   */\n  static #emit(detail) {\n    const required = {\n      type: null,\n      key: null,\n      action: null,\n      data: null\n    }\n    detail = { ...required, ...detail }\n    const event = new CustomEvent('Satchel', {\n      bubbles: true,\n      cancelable: true,\n      detail\n    })\n    return document.dispatchEvent(event)\n  }\n\n  /**\n   * Clears all items regardless of freshness from a given 'pocket' namespace\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns {array} The number of items remaing in store, which if sucessful should be 0.\n   */\n  static emptyPocket(pocket = 'pocket', local = false) {\n    const store = local ? window.localStorage : window.sessionStorage\n    const keysBefore = Satchel.getAllPocketKeys(pocket, local)\n    if (!keysBefore.length) {\n      console.warn('No pocket keys found for ' + pocket + ' in ' + store)\n      return keysBefore\n    }\n\n    Object.keys(keysBefore).forEach((key) => {\n      store.removeItem(keysBefore[key])\n    })\n    const keysRemaining = Satchel.getAllPocketKeys(pocket, local)\n\n    document.dispatchEvent(\n      new CustomEvent('Satchel', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          action: 'emptyPocket',\n          keysBefore,\n          keysRemaining\n        }\n      })\n    )\n    return keysRemaining\n  }\n\n  /**\n   *  Removes all expired items from a given 'pocket' namespace\n   *\n   * @param {string} pocket namespace prefix, default 'pocket'\n   * @param {boolean} local specify sessionStorage (default) or localStorage\n   * @returns The number of items remaing in store that have yet to expire.\n   */\n  static tidyPocket(pocket = 'pocket', local = false) {\n    const store = local ? localStorage : sessionStorage\n    const keysBefore = Satchel.getAllPocketKeys(pocket, local)\n    if (!keysBefore.length) return null\n\n    Object.keys(keysBefore).forEach((key) => {\n      const expiry = JSON.parse(store.getItem(keysBefore[key])).expiry\n      if (!expiry || expiry - Date.now() > 0) return null\n      store.removeItem(keysBefore[key])\n    })\n    const keysRemaining = Satchel.getAllPocketKeys(pocket, local).length\n    document.dispatchEvent(\n      new CustomEvent('Satchel', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          action: 'tidyPocket',\n          keysBefore: keysBefore.length,\n          keysRemaining\n        }\n      })\n    )\n\n    return keysRemaining\n  }\n\n  /**\n   * Returns an instance of Satchel associated with the given key, pocket,store, or false if none is found.\n   *\n   * @param {string} key key for the stored item\n   * @param {string} [pocket='pocket'] namespace prefix, default 'pocket'\n   * @param {string} [local='false'] specify sessionStorage (default) or localStorage\n   * @returns {Satchel|false} new Satchel instance | false\n   */\n  static getSatchel(key, pocket = 'pocket', local = false) {\n    const pocketKey = `${Satchel.stcl}.${pocket}.${key}`\n    const store = local ? localStorage : sessionStorage\n    const item = JSON.parse(store.getItem(pocketKey))\n    if (!item) return false\n\n    return new Satchel(key, item, local, pocket)\n  }\n}\n\nSatchel.stcl = 'stcl'\nexport { Satchel }\n"],"names":["Satchel","cargo","pocketKey","store","settings","constructor","key","local","pocket","this","window","localStorage","sessionStorage","Error","stcl","data","undefined","expiry","Object","defineProperty","enumerable","writable","value","Date","now","set","age","JSON","parse","getItem","creation","fresh","isFresh","bin","removeItem","emit","type","action","get","ignore","item","storedEntry","temp","setItem","stringify","oldData","getKey","static","keys","map","startsWith","filter","e","detail","event","CustomEvent","bubbles","cancelable","document","dispatchEvent","keysBefore","getAllPocketKeys","length","console","warn","forEach","keysRemaining"],"mappings":"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"}